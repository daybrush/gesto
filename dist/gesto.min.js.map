{"version":3,"file":"gesto.min.js","sources":["../src/utils.ts","../src/ClientStore.ts","../src/Gesto.ts","../src/index.umd.ts"],"sourcesContent":["import { Client, Position } from \"./types\";\nimport { IArrayFormat } from \"@daybrush/utils\";\n\nexport function getRad(pos1: number[], pos2: number[]) {\n    const distX = pos2[0] - pos1[0];\n    const distY = pos2[1] - pos1[1];\n    const rad = Math.atan2(distY, distX);\n\n    return rad >= 0 ? rad : rad + Math.PI * 2;\n}\n\nexport function getRotatiion(touches: Client[]) {\n    return getRad([\n        touches[0].clientX,\n        touches[0].clientY,\n    ], [\n        touches[1].clientX,\n        touches[1].clientY,\n    ]) / Math.PI * 180;\n}\n\nexport function isMultiTouch(e: any): e is TouchEvent {\n    return e.touches && e.touches.length >= 2;\n}\nexport function getEventClients(e: any): Client[] {\n    if (e.touches) {\n        return getClients(e.touches);\n    } else {\n        return [getClient(e)];\n    }\n}\nexport function getPosition(clients: Client[], prevClients: Client[], startClients: Client[]): Position {\n    const length = startClients.length;\n    const {\n        clientX, clientY,\n        originalClientX, originalClientY,\n    } = getAverageClient(clients, length);\n    const {\n        clientX: prevX,\n        clientY: prevY,\n    } = getAverageClient(prevClients, length);\n\n    const {\n        clientX: startX,\n        clientY: startY,\n    } = getAverageClient(startClients, length);\n    const deltaX = clientX - prevX;\n    const deltaY = clientY - prevY;\n    const distX = clientX - startX;\n    const distY = clientY - startY;\n\n    return {\n        clientX: originalClientX!,\n        clientY: originalClientY!,\n        deltaX,\n        deltaY,\n        distX,\n        distY,\n    };\n}\nexport function getDist(clients: Client[]) {\n    return Math.sqrt(\n        Math.pow(clients[0].clientX - clients[1].clientX, 2)\n        + Math.pow(clients[0].clientY - clients[1].clientY, 2),\n    );\n}\nexport function getClients(touches: IArrayFormat<Touch>) {\n    const length = Math.min(touches.length, 2);\n    const clients = [];\n\n    for (let i = 0; i < length; ++i) {\n        clients.push(getClient(touches[i]));\n    }\n    return clients;\n}\nexport function getClient(e: MouseEvent | Touch): Client {\n    return {\n        clientX: e.clientX,\n        clientY: e.clientY,\n    };\n}\nexport function getAverageClient(clients: Client[], length = clients.length): Required<Client> {\n    const sumClient: Required<Client> = {\n        clientX: 0,\n        clientY: 0,\n        originalClientX: 0,\n        originalClientY: 0,\n    };\n    for (let i = 0; i < length; ++i) {\n        const client = clients[i];\n\n        sumClient.originalClientX += \"originalClientX\" in client ? client.originalClientX! : client.clientX;\n        sumClient.originalClientY += \"originalClientY\" in client ? client.originalClientY! : client.clientY;\n        sumClient.clientX += client.clientX;\n        sumClient.clientY += client.clientY;\n    }\n    if (!length) {\n        return sumClient;\n    }\n    return {\n        clientX: sumClient.clientX / length,\n        clientY: sumClient.clientY / length,\n        originalClientX: sumClient.originalClientX / length,\n        originalClientY: sumClient.originalClientY / length,\n    };\n}\nexport function plueClient(client1: Client, client2: Client) {\n    return {\n        clientX: (client1.clientX + client2.clientX),\n        clientY: (client1.clientY + client2.clientY),\n    };\n}\n\nexport function minusClient(client1: Client, client2: Client) {\n    return {\n        clientX: (client1.clientX - client2.clientX),\n        clientY: (client1.clientY - client2.clientY),\n    };\n}\n","import { Client } from \"./types\";\nimport { getPosition, getDist, getRotatiion, getAverageClient } from \"./utils\";\n\nexport class ClientStore {\n    public prevClients: Client[] = [];\n    public startClients: Client[] = [];\n    public movement = 0;\n    public length  = 0;\n    constructor(clients: Client[]) {\n        this.startClients = clients;\n        this.prevClients = clients;\n        this.length = clients.length;\n    }\n    public addClients(clients: Client[] = this.prevClients) {\n        const position = this.getPosition(clients);\n        const { deltaX, deltaY } = position;\n\n        this.movement += Math.sqrt(deltaX * deltaX + deltaY * deltaY);\n        this.prevClients = clients;\n\n        return position;\n    }\n    public getAngle(clients: Client[] = this.prevClients) {\n        return getRotatiion(clients);\n    }\n    public getRotation(clients: Client[] = this.prevClients) {\n        return getRotatiion(clients) - getRotatiion(this.startClients);\n    }\n    public getPosition(clients?: Client[]) {\n        return getPosition(clients || this.prevClients, this.prevClients, this.startClients);\n    }\n    public getPositions(clients: Client[] = this.prevClients) {\n        const prevClients = this.prevClients;\n\n        return this.startClients.map((startClient, i) => getPosition([clients[i]], [prevClients[i]], [startClient]));\n    }\n    public getMovement(clients?: Client[]) {\n        const movement = this.movement;\n\n        if (!clients) {\n            return movement;\n        }\n        const currentClient = getAverageClient(clients, this.length);\n        const prevClient = getAverageClient(this.prevClients, this.length);\n        const deltaX = currentClient.clientX - prevClient.clientX;\n        const deltaY = currentClient.clientY - prevClient.clientY;\n\n        return Math.sqrt(deltaX * deltaX + deltaY * deltaY) + movement;\n    }\n    public getDistance(clients = this.prevClients) {\n        return getDist(clients);\n    }\n    public getScale(clients = this.prevClients) {\n        return getDist(clients) / getDist(this.startClients);\n    }\n    public move(deltaX: number, deltaY: number) {\n        this.startClients.forEach(client => {\n            client.clientX -= deltaX;\n            client.clientY -= deltaY;\n        });\n        this.prevClients.forEach(client => {\n            client.clientX -= deltaX;\n            client.clientY -= deltaY;\n        });\n    }\n}\n","import { Client, OnDrag, GestoOptions, GestoEvents, ComponentTriggerType } from \"./types\";\nimport {\n    getEventClients, isMultiTouch,\n} from \"./utils\";\nimport Component from \"@egjs/component\";\nimport { addEvent, removeEvent, now } from \"@daybrush/utils\";\nimport { ClientStore } from \"./ClientStore\";\n\nconst INPUT_TAGNAMES = [\"textarea\", \"input\"];\n/**\n * You can set up drag, pinch events in any browser.\n */\nclass Gesto extends Component {\n    public options: GestoOptions = {};\n    private flag = false;\n    private pinchFlag = false;\n    private datas = {};\n    private isDrag = false;\n    private isPinch = false;\n    private isMouse = false;\n    private isTouch = false;\n    private clientStores: ClientStore[] = [];\n    private targets: Array<Element | Window> = [];\n    private prevTime: number = 0;\n    private isDouble: boolean = false;\n\n    /**\n     *\n     */\n    constructor(targets: Array<Element | Window> | Element | Window, options: GestoOptions = {}) {\n        super();\n        const elements = [].concat(targets as any) as Array<Element | Window>;\n        this.options = {\n            checkInput: false,\n            container: elements.length > 1 ? window : elements[0],\n            preventRightClick: true,\n            preventDefault: true,\n            pinchThreshold: 0,\n            events: [\"touch\", \"mouse\"],\n            ...options,\n        };\n\n        const { container, events } = this.options;\n\n        this.isTouch = events!.indexOf(\"touch\") > -1;\n        this.isMouse = events!.indexOf(\"mouse\") > -1;\n        this.targets = elements;\n\n        if (this.isMouse) {\n            elements.forEach(el => {\n                addEvent(el, \"mousedown\", this.onDragStart);\n            });\n            addEvent(container!, \"mousemove\", this.onDrag);\n            addEvent(container!, \"mouseup\", this.onDragEnd);\n            addEvent(container!, \"contextmenu\", this.onDragEnd);\n        }\n        if (this.isTouch) {\n            const passive = {\n                passive: false,\n            };\n            elements.forEach(el => {\n                addEvent(el, \"touchstart\", this.onDragStart, passive);\n            });\n            addEvent(container!, \"touchmove\", this.onDrag, passive);\n            addEvent(container!, \"touchend\", this.onDragEnd, passive);\n            addEvent(container!, \"touchcancel\", this.onDragEnd, passive);\n        }\n    }\n    /**\n     * The total moved distance\n     */\n    public getMovement(clients?: Client[]) {\n        return this.getCurrentStore().getMovement(clients) + this.clientStores.slice(1).reduce((prev, cur) => {\n            return prev + cur.movement;\n        },  0);\n    }\n    /**\n     * Whether to drag\n     */\n    public isDragging(): boolean {\n        return this.isDrag;\n    }\n    /**\n     * Whether to start drag\n     */\n    public isFlag(): boolean {\n        return this.flag;\n    }\n    /**\n     * Whether to start pinch\n     */\n    public isPinchFlag() {\n        return this.pinchFlag;\n    }\n    /**\n     * Whether to pinch\n     */\n    public isPinching() {\n        return this.isPinch;\n    }\n    /**\n     * If a scroll event occurs, it is corrected by the scroll distance.\n     */\n    public scrollBy(deltaX: number, deltaY: number, e: any, isCallDrag: boolean = true) {\n        if (!this.flag) {\n            return;\n        }\n        this.clientStores[0].move(deltaX, deltaY);\n        isCallDrag && this.onDrag(e, true);\n    }\n    /**\n     * Create a virtual drag event.\n     */\n    public move([deltaX, deltaY]: number[], inputEvent: any): ComponentTriggerType<OnDrag> {\n        const store = this.getCurrentStore();\n        const nextClients = store.prevClients;\n\n        return this.moveClients(nextClients.map(({ clientX, clientY }) => {\n            return {\n                clientX: clientX + deltaX,\n                clientY: clientY + deltaY,\n                originalClientX: clientX,\n                originalClientY: clientY,\n            };\n        }), inputEvent, true);\n    }\n    /**\n     * The dragStart event is triggered by an external event.\n     */\n    public triggerDragStart(e: any) {\n        this.onDragStart(e, false);\n    }\n    /**\n     * Unset Gesto\n     */\n    public unset() {\n        const targets = this.targets;\n        const container = this.options.container!;\n\n        this.off();\n        if (this.isMouse) {\n            targets.forEach(target => {\n                removeEvent(target, \"mousedown\", this.onDragStart);\n            });\n            removeEvent(container, \"mousemove\", this.onDrag);\n            removeEvent(container, \"mouseup\", this.onDragEnd);\n            removeEvent(container, \"contextmenu\", this.onDragEnd);\n        }\n        if (this.isTouch) {\n            targets.forEach(target => {\n                removeEvent(target, \"touchstart\", this.onDragStart);\n            });\n            removeEvent(container, \"touchstart\", this.onDragStart);\n            removeEvent(container, \"touchmove\", this.onDrag);\n            removeEvent(container, \"touchend\", this.onDragEnd);\n            removeEvent(container, \"touchcancel\", this.onDragEnd);\n        }\n    }\n    public onDragStart = (e: any, isTrusted = true) => {\n        if (!this.flag && e.cancelable === false) {\n            return;\n        }\n        const { container, pinchOutside, preventRightClick, preventDefault, checkInput } = this.options;\n        const isTouch = this.isTouch;\n        const isDragStart = !this.flag;\n\n        if (isDragStart) {\n            const activeElement = document.activeElement as HTMLElement;\n            const target = e.target as HTMLElement;\n            const tagName = target.tagName.toLowerCase();\n            const hasInput = INPUT_TAGNAMES.indexOf(tagName) > -1;\n            const hasContentEditable = target.isContentEditable;\n\n            if (hasInput || hasContentEditable) {\n                if (checkInput || activeElement === target) {\n                    // force false or already focused.\n                    return false;\n                }\n                if (\n                    activeElement\n                    && hasContentEditable\n                    && activeElement.isContentEditable\n                    && activeElement.contains(target)\n                ) {\n                    return false;\n                }\n            } else if ((preventDefault || e.type === \"touchstart\") && activeElement) {\n                const activeTagName = activeElement.tagName;\n                if (activeElement.isContentEditable || INPUT_TAGNAMES.indexOf(activeTagName) > -1) {\n                    activeElement.blur();\n                }\n            }\n            this.clientStores = [new ClientStore(getEventClients(e))];\n            this.flag = true;\n            this.isDrag = false;\n            this.datas = {};\n\n            if (preventRightClick && (e.which === 3 || e.button === 2)) {\n                this.initDrag();\n                return false;\n            }\n            const result = this.trigger(\"dragStart\", {\n                datas: this.datas,\n                inputEvent: e,\n                isTrusted,\n                ...this.getCurrentStore().getPosition(),\n            });\n            if (result === false) {\n                this.initDrag();\n            }\n            this.isDouble = now() - this.prevTime < 200;\n            this.flag && preventDefault && e.preventDefault();\n        }\n        if (!this.flag) {\n            return false;\n        }\n        let timer = 0;\n\n        if (isDragStart && isTouch && pinchOutside) {\n            timer = setTimeout(() => {\n                addEvent(container!, \"touchstart\", this.onDragStart, { passive: false });\n            });\n        }\n        if (!isDragStart && isTouch && pinchOutside) {\n            removeEvent(container!, \"touchstart\", this.onDragStart);\n        }\n        if (this.flag && isMultiTouch(e)) {\n            clearTimeout(timer);\n            if (isDragStart && (e.touches.length !== e.changedTouches.length)) {\n                return;\n            }\n            if (!this.pinchFlag) {\n                this.onPinchStart(e);\n            }\n        }\n\n    }\n    public onDrag = (e: any, isScroll?: boolean) => {\n        if (!this.flag) {\n            return;\n        }\n        const clients = getEventClients(e);\n        const result = this.moveClients(clients, e, false);\n\n        if (this.pinchFlag || result.deltaX || result.deltaY) {\n            this.trigger(\"drag\", {\n                ...result,\n                isScroll: !!isScroll,\n                inputEvent: e,\n            });\n        }\n        if (this.pinchFlag) {\n            this.onPinch(e, clients);\n        }\n\n        this.getCurrentStore().addClients(clients);\n    }\n    public onDragEnd = (e: any) => {\n        if (!this.flag) {\n            return;\n        }\n        const { pinchOutside, container } = this.options;\n        if (this.isTouch && pinchOutside) {\n            removeEvent(container!, \"touchstart\", this.onDragStart);\n        }\n\n        this.flag = false;\n\n        const position = this.getCurrentStore().getPosition();\n\n        const currentTime = now();\n        const isDouble = !this.isDrag && this.isDouble;\n\n        this.prevTime = this.isDrag || isDouble ? 0 : currentTime;\n\n        this.trigger(\"dragEnd\", {\n            datas: this.datas,\n            isDouble,\n            isDrag: this.isDrag,\n            inputEvent: e,\n            ...position,\n        });\n        if (this.pinchFlag) {\n            this.onPinchEnd(e);\n        }\n        this.clientStores = [];\n    }\n    public onPinchStart(e: TouchEvent) {\n        const { pinchThreshold } = this.options;\n\n        if (this.isDrag && this.getMovement() > pinchThreshold!) {\n            return;\n        }\n        const store = new ClientStore(getEventClients(e));\n\n        this.pinchFlag = true;\n        this.clientStores.splice(0, 0, store);\n\n        const result = this.trigger(\"pinchStart\", {\n            datas: this.datas,\n            angle: store.getAngle(),\n            touches: this.getCurrentStore().getPositions(),\n            ...store.getPosition(),\n            inputEvent: e,\n        });\n\n        if (result === false) {\n            this.pinchFlag = false;\n        }\n    }\n    public onPinch(e: TouchEvent, clients: Client[]) {\n        if (!this.flag || !this.pinchFlag || clients.length < 2) {\n            return;\n        }\n\n        const store = this.getCurrentStore();\n        this.isPinch = true;\n\n        this.trigger(\"pinch\", {\n            datas: this.datas,\n            movement: this.getMovement(clients),\n            angle: store.getAngle(clients),\n            rotation: store.getRotation(clients),\n            touches: store.getPositions(clients),\n            scale: store.getScale(clients),\n            distance: store.getDistance(clients),\n            ...store.getPosition(clients),\n            inputEvent: e,\n        });\n    }\n    public onPinchEnd(e: TouchEvent) {\n        if (!this.pinchFlag) {\n            return;\n        }\n        const isPinch = this.isPinch;\n\n        this.isPinch = false;\n        this.pinchFlag = false;\n        const store = this.getCurrentStore();\n        this.trigger(\"pinchEnd\", {\n            datas: this.datas,\n            isPinch,\n            touches: store.getPositions(),\n            ...store.getPosition(),\n            inputEvent: e,\n        });\n        this.isPinch = false;\n        this.pinchFlag = false;\n    }\n\n    private initDrag() {\n        this.clientStores = [];\n        this.pinchFlag = false;\n        this.flag = false;\n    }\n    private getCurrentStore() {\n        return this.clientStores[0];\n    }\n    private moveClients(clients: Client[], inputEvent: any, isAdd: boolean): ComponentTriggerType<OnDrag> {\n        const store = this.getCurrentStore();\n        const position = store[isAdd ? \"addClients\" : \"getPosition\"](clients);\n\n        this.isDrag = true;\n\n        return {\n            datas: this.datas,\n            ...position,\n            movement: this.getMovement(clients),\n            isDrag: this.isDrag,\n            isPinch: this.isPinch,\n            isScroll: false,\n            inputEvent,\n        };\n    }\n}\n\ninterface Gesto {\n    on<T extends keyof GestoEvents>(\n        eventName: T, handlerToAttach: (event: GestoEvents[T]) => any): this;\n    on(eventName: string, handlerToAttach: (event: { [key: string]: any }) => any): this;\n    on(events: { [key: string]: (event: { [key: string]: any }) => any }): this;\n    trigger<T extends keyof GestoEvents>(eventName: T, param: ComponentTriggerType<GestoEvents[T]>): boolean;\n    trigger(eventName: string, param: { [key: string]: any }): boolean;\n}\nexport default Gesto;\n","\nimport Dragger, * as modules from \"./index\";\n\nfor (const name in modules) {\n    (Dragger as any)[name] = (modules as any)[name];\n}\n\nexport default Dragger;\n"],"names":["getRotatiion","touches","pos1","pos2","distX","distY","rad","Math","atan2","PI","getRad","clientX","clientY","getEventClients","e","length","min","clients","i","push","getClient","getClients","getPosition","prevClients","startClients","_a","originalClientX","originalClientY","_b","prevX","prevY","_c","deltaX","deltaY","getDist","sqrt","pow","getAverageClient","sumClient","client","this","position","movement","map","startClient","currentClient","prevClient","forEach","INPUT_TAGNAMES","targets","options","_super","_this","isTrusted","flag","cancelable","container","pinchOutside","preventRightClick","preventDefault","checkInput","isTouch","isDragStart","activeElement","document","target","tagName","toLowerCase","hasInput","indexOf","hasContentEditable","isContentEditable","contains","type","activeTagName","blur","clientStores","ClientStore","isDrag","datas","which","button","initDrag","trigger","inputEvent","getCurrentStore","isDouble","now","prevTime","timer","setTimeout","addEvent","onDragStart","passive","removeEvent","isMultiTouch","clearTimeout","changedTouches","pinchFlag","onPinchStart","isScroll","result","moveClients","onPinch","addClients","currentTime","onPinchEnd","elements","concat","window","pinchThreshold","events","isMouse","el","onDrag","onDragEnd","passive_1","tslib_1","getMovement","slice","reduce","prev","cur","isPinch","isCallDrag","move","nextClients","off","store","splice","angle","getAngle","getPositions","rotation","getRotation","scale","getScale","distance","getDistance","isAdd","Component","name","modules","Dragger"],"mappings":"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"}