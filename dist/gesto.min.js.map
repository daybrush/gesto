{"version":3,"file":"gesto.min.js","sources":["../src/utils.ts","../src/ClientStore.ts","../src/Gesto.ts","../src/index.umd.ts"],"sourcesContent":["import { Client, Position } from \"./types\";\nimport { IArrayFormat, isNumber } from \"@daybrush/utils\";\n\nexport function getRad(pos1: number[], pos2: number[]) {\n    const distX = pos2[0] - pos1[0];\n    const distY = pos2[1] - pos1[1];\n    const rad = Math.atan2(distY, distX);\n\n    return rad >= 0 ? rad : rad + Math.PI * 2;\n}\n\nexport function getRotatiion(touches: Client[]) {\n    return getRad([\n        touches[0].clientX,\n        touches[0].clientY,\n    ], [\n        touches[1].clientX,\n        touches[1].clientY,\n    ]) / Math.PI * 180;\n}\n\nexport function isMultiTouch(e: any): e is TouchEvent {\n    return e.touches && e.touches.length >= 2;\n}\nexport function getEventClients(e: any): Client[] {\n    if (!e) {\n        return [];\n    } if (e.touches) {\n        return getClients(e.touches);\n    } else {\n        return [getClient(e)];\n    }\n}\nexport function isMouseEvent(e: any): e is MouseEvent {\n    return e && (e.type.indexOf(\"mouse\") > -1 || \"button\" in e);\n}\nexport function getPosition(clients: Client[], prevClients: Client[], startClients: Client[]): Position {\n    const length = startClients.length;\n    const {\n        clientX, clientY,\n        originalClientX, originalClientY,\n    } = getAverageClient(clients, length);\n    const {\n        clientX: prevX,\n        clientY: prevY,\n    } = getAverageClient(prevClients, length);\n\n    const {\n        clientX: startX,\n        clientY: startY,\n    } = getAverageClient(startClients, length);\n    const deltaX = clientX - prevX;\n    const deltaY = clientY - prevY;\n    const distX = clientX - startX;\n    const distY = clientY - startY;\n\n    return {\n        clientX: originalClientX!,\n        clientY: originalClientY!,\n        deltaX,\n        deltaY,\n        distX,\n        distY,\n    };\n}\nexport function getDist(clients: Client[]) {\n    return Math.sqrt(\n        Math.pow(clients[0].clientX - clients[1].clientX, 2)\n        + Math.pow(clients[0].clientY - clients[1].clientY, 2),\n    );\n}\nexport function getClients(touches: IArrayFormat<Touch>) {\n    const length = Math.min(touches.length, 2);\n    const clients = [];\n\n    for (let i = 0; i < length; ++i) {\n        clients.push(getClient(touches[i]));\n    }\n    return clients;\n}\nexport function getClient(e: MouseEvent | Touch): Client {\n    return {\n        clientX: e.clientX,\n        clientY: e.clientY,\n    };\n}\nexport function getAverageClient(clients: Client[], length = clients.length): Required<Client> {\n    const sumClient: Required<Client> = {\n        clientX: 0,\n        clientY: 0,\n        originalClientX: 0,\n        originalClientY: 0,\n    };\n    for (let i = 0; i < length; ++i) {\n        const client = clients[i];\n\n        sumClient.originalClientX += \"originalClientX\" in client ? client.originalClientX! : client.clientX;\n        sumClient.originalClientY += \"originalClientY\" in client ? client.originalClientY! : client.clientY;\n        sumClient.clientX += client.clientX;\n        sumClient.clientY += client.clientY;\n    }\n    if (!length) {\n        return sumClient;\n    }\n    return {\n        clientX: sumClient.clientX / length,\n        clientY: sumClient.clientY / length,\n        originalClientX: sumClient.originalClientX / length,\n        originalClientY: sumClient.originalClientY / length,\n    };\n}\nexport function plueClient(client1: Client, client2: Client) {\n    return {\n        clientX: (client1.clientX + client2.clientX),\n        clientY: (client1.clientY + client2.clientY),\n    };\n}\n\nexport function minusClient(client1: Client, client2: Client) {\n    return {\n        clientX: (client1.clientX - client2.clientX),\n        clientY: (client1.clientY - client2.clientY),\n    };\n}\n","import { Client } from \"./types\";\nimport { getPosition, getDist, getRotatiion, getAverageClient } from \"./utils\";\n\nexport class ClientStore {\n    public prevClients: Client[] = [];\n    public startClients: Client[] = [];\n    public movement = 0;\n    public length  = 0;\n    constructor(clients: Client[]) {\n        this.startClients = clients;\n        this.prevClients = clients;\n        this.length = clients.length;\n    }\n    public getAngle(clients: Client[] = this.prevClients) {\n        return getRotatiion(clients);\n    }\n    public getRotation(clients: Client[] = this.prevClients) {\n        return getRotatiion(clients) - getRotatiion(this.startClients);\n    }\n    public getPosition(clients: Client[] = this.prevClients, isAdd?: boolean) {\n        const position = getPosition(clients || this.prevClients, this.prevClients, this.startClients);\n\n        const { deltaX, deltaY } = position;\n\n        this.movement += Math.sqrt(deltaX * deltaX + deltaY * deltaY);\n        this.prevClients = clients;\n\n        return position;\n    }\n    public getPositions(clients: Client[] = this.prevClients) {\n        const prevClients = this.prevClients;\n\n        return this.startClients.map((startClient, i) => getPosition([clients[i]], [prevClients[i]], [startClient]));\n    }\n    public getMovement(clients?: Client[]) {\n        const movement = this.movement;\n\n        if (!clients) {\n            return movement;\n        }\n        const currentClient = getAverageClient(clients, this.length);\n        const prevClient = getAverageClient(this.prevClients, this.length);\n        const deltaX = currentClient.clientX - prevClient.clientX;\n        const deltaY = currentClient.clientY - prevClient.clientY;\n\n        return Math.sqrt(deltaX * deltaX + deltaY * deltaY) + movement;\n    }\n    public getDistance(clients = this.prevClients) {\n        return getDist(clients);\n    }\n    public getScale(clients = this.prevClients) {\n        return getDist(clients) / getDist(this.startClients);\n    }\n    public move(deltaX: number, deltaY: number) {\n        this.startClients.forEach(client => {\n            client.clientX -= deltaX;\n            client.clientY -= deltaY;\n        });\n    }\n}\n","import { Client, OnDrag, GestoOptions, GestoEvents } from \"./types\";\nimport {\n    getEventClients, isMouseEvent, isMultiTouch,\n} from \"./utils\";\nimport EventEmitter, { TargetParam } from \"@scena/event-emitter\";\nimport { addEvent, removeEvent, now, IObject } from \"@daybrush/utils\";\nimport { ClientStore } from \"./ClientStore\";\n\nconst INPUT_TAGNAMES = [\"textarea\", \"input\"];\n/**\n * You can set up drag, pinch events in any browser.\n */\nclass Gesto extends EventEmitter<GestoEvents> {\n    public options: GestoOptions = {};\n    private flag = false;\n    private pinchFlag = false;\n    private data: IObject<any> = {};\n    private isDrag = false;\n    private isPinch = false;\n    private isMouse = false;\n    private isTouch = false;\n    private clientStores: ClientStore[] = [];\n    private targets: Array<Element | Window> = [];\n    private prevTime: number = 0;\n    private doubleFlag: boolean = false;\n    private _dragFlag = false;\n    private _isMouseEvent = false;\n    private _isSecondaryButton = false;\n    private _preventMouseEvent = false;\n\n    /**\n     *\n     */\n    constructor(targets: Array<Element | Window> | Element | Window, options: GestoOptions = {}) {\n        super();\n        const elements = [].concat(targets as any) as Array<Element | Window>;\n        this.options = {\n            checkInput: false,\n            container: elements.length > 1 ? window : elements[0],\n            preventRightClick: true,\n            preventWheelClick: true,\n            preventClickEventOnDragStart: false,\n            preventClickEventOnDrag: false,\n            preventClickEventByCondition: null,\n            preventDefault: true,\n            checkWindowBlur: false,\n            keepDragging: false,\n            pinchThreshold: 0,\n            events: [\"touch\", \"mouse\"],\n            ...options,\n        };\n\n        const { container, events, checkWindowBlur } = this.options;\n\n        this.isTouch = events!.indexOf(\"touch\") > -1;\n        this.isMouse = events!.indexOf(\"mouse\") > -1;\n        this.targets = elements;\n\n        if (this.isMouse) {\n            elements.forEach(el => {\n                addEvent(el, \"mousedown\", this.onDragStart);\n                addEvent(el, \"mousemove\", this._passCallback);\n            });\n            addEvent(container!, \"contextmenu\", this._onContextMenu);\n        }\n        if (checkWindowBlur) {\n            addEvent(window, \"blur\", this.onBlur);\n        }\n        if (this.isTouch) {\n            const passive = {\n                passive: false,\n            };\n            elements.forEach(el => {\n                addEvent(el, \"touchstart\", this.onDragStart, passive);\n                addEvent(el, \"touchmove\", this._passCallback, passive);\n            });\n        }\n    }\n    /**\n     * Stop Gesto's drag events.\n     */\n    public stop() {\n        this.isDrag = false;\n        this.data = {};\n        this.clientStores = [];\n        this.pinchFlag = false;\n        this.doubleFlag = false;\n        this.prevTime = 0;\n        this.flag = false;\n\n        this._allowClickEvent();\n        this._dettachDragEvent();\n    }\n    /**\n     * The total moved distance\n     */\n    public getMovement(clients?: Client[]) {\n        return this.getCurrentStore().getMovement(clients) + this.clientStores.slice(1).reduce((prev, cur) => {\n            return prev + cur.movement;\n        }, 0);\n    }\n    /**\n     * Whether to drag\n     */\n    public isDragging(): boolean {\n        return this.isDrag;\n    }\n    /**\n     * Whether to start drag\n     */\n    public isFlag(): boolean {\n        return this.flag;\n    }\n    /**\n     * Whether to start pinch\n     */\n    public isPinchFlag() {\n        return this.pinchFlag;\n    }\n    /**\n     * Whether to start double click\n     */\n    public isDoubleFlag() {\n        return this.doubleFlag;\n    }\n    /**\n     * Whether to pinch\n     */\n    public isPinching() {\n        return this.isPinch;\n    }\n\n    /**\n     * If a scroll event occurs, it is corrected by the scroll distance.\n     */\n    public scrollBy(deltaX: number, deltaY: number, e: any, isCallDrag: boolean = true) {\n        if (!this.flag) {\n            return;\n        }\n        this.clientStores[0].move(deltaX, deltaY);\n        isCallDrag && this.onDrag(e, true);\n    }\n    /**\n     * Create a virtual drag event.\n     */\n    public move([deltaX, deltaY]: number[], inputEvent: any): TargetParam<OnDrag> {\n        const store = this.getCurrentStore();\n        const nextClients = store.prevClients;\n\n        return this.moveClients(nextClients.map(({ clientX, clientY }) => {\n            return {\n                clientX: clientX + deltaX,\n                clientY: clientY + deltaY,\n                originalClientX: clientX,\n                originalClientY: clientY,\n            };\n        }), inputEvent, true);\n    }\n    /**\n     * The dragStart event is triggered by an external event.\n     */\n    public triggerDragStart(e: any) {\n        this.onDragStart(e, false);\n    }\n    /**\n     * Set the event data while dragging.\n     */\n    public setEventData(data: IObject<any>) {\n        const currentData = this.data;\n\n        for (const name in data) {\n            currentData[name] = data[name];\n        }\n        return this;\n    }\n    /**\n     * Set the event data while dragging.\n     * Use `setEventData`\n     * @deprecated\n     */\n    public setEventDatas(data: IObject<any>) {\n        return this.setEventData(data);\n    }\n    /**\n     * Get the current event state while dragging.\n     */\n    public getCurrentEvent(inputEvent?: any) {\n        return {\n            data: this.data,\n            datas: this.data,\n            ...this._getPosition(),\n            movement: this.getMovement(),\n            isDrag: this.isDrag,\n            isPinch: this.isPinch,\n            isScroll: false,\n            inputEvent,\n        };\n    }\n    /**\n     * Get & Set the event data while dragging.\n     */\n    public getEventData() {\n        return this.data;\n    }\n    /**\n     * Get & Set the event data while dragging.\n     * Use getEventData method\n     * @depreacated\n     */\n    public getEventDatas() {\n        return this.data;\n    }\n    /**\n     * Unset Gesto\n     */\n    public unset() {\n        const targets = this.targets;\n        const container = this.options.container!;\n\n        this.off();\n        removeEvent(window, \"blur\", this.onBlur);\n        if (this.isMouse) {\n            targets.forEach(target => {\n                removeEvent(target, \"mousedown\", this.onDragStart);\n            });\n            removeEvent(container, \"contextmenu\", this._onContextMenu);\n        }\n        if (this.isTouch) {\n            targets.forEach(target => {\n                removeEvent(target, \"touchstart\", this.onDragStart);\n            });\n            removeEvent(container, \"touchstart\", this.onDragStart);\n        }\n        this._allowClickEvent();\n        this._dettachDragEvent();\n    }\n    public onDragStart = (e: any, isTrusted = true) => {\n        if (!this.flag && e.cancelable === false) {\n            return;\n        }\n        const {\n            container,\n            pinchOutside,\n            preventWheelClick,\n            preventRightClick,\n            preventDefault,\n            checkInput,\n            preventClickEventOnDragStart,\n            preventClickEventOnDrag,\n            preventClickEventByCondition,\n        } = this.options;\n        const isTouch = this.isTouch;\n        const isDragStart = !this.flag;\n\n        this._isSecondaryButton = e.which === 3 || e.button === 2;\n\n        if (\n            (preventWheelClick && (e.which === 2 || e.button === 1))\n            || (preventRightClick && (e.which === 3 || e.button === 2))\n        ) {\n            this.stop();\n            return false;\n        }\n\n        if (isDragStart) {\n            const activeElement = document.activeElement as HTMLElement;\n            const target = e.target as HTMLElement;\n\n           if (target) {\n                const tagName = target.tagName.toLowerCase();\n                const hasInput = INPUT_TAGNAMES.indexOf(tagName) > -1;\n                const hasContentEditable = target.isContentEditable;\n\n                if (hasInput || hasContentEditable) {\n                    if (checkInput || activeElement === target) {\n                        // force false or already focused.\n                        return false;\n                    }\n                    // no focus\n                    if (\n                        activeElement\n                        && hasContentEditable\n                        && activeElement.isContentEditable\n                        && activeElement.contains(target)\n                    ) {\n                        return false;\n                    }\n                } else if ((preventDefault || e.type === \"touchstart\") && activeElement) {\n                    const activeTagName = activeElement.tagName.toLowerCase();\n\n                    if (activeElement.isContentEditable || INPUT_TAGNAMES.indexOf(activeTagName) > -1) {\n                        activeElement.blur();\n                    }\n                }\n\n                if (preventClickEventOnDragStart || preventClickEventOnDrag || preventClickEventByCondition) {\n                    addEvent(window, \"click\", this._onClick, true);\n                }\n            }\n            this.clientStores = [new ClientStore(getEventClients(e))];\n            this.flag = true;\n            this.isDrag = false;\n            this._dragFlag = true;\n            this.data = {};\n\n            this.doubleFlag = now() - this.prevTime < 200;\n            this._isMouseEvent = isMouseEvent(e);\n            if (!this._isMouseEvent && this._preventMouseEvent) {\n                this._preventMouseEvent = false;\n            }\n\n            const result = this._preventMouseEvent || this.emit(\"dragStart\", {\n                data: this.data,\n                datas: this.data,\n                inputEvent: e,\n                isMouseEvent: this._isMouseEvent,\n                isSecondaryButton: this._isSecondaryButton,\n                isTrusted,\n                isDouble: this.doubleFlag,\n                ...this.getCurrentStore().getPosition(),\n                preventDefault() {\n                    e.preventDefault();\n                },\n                preventDrag: () => {\n                    this._dragFlag = false;\n                },\n            });\n            if (result === false) {\n                this.stop();\n            }\n            if (this._isMouseEvent && this.flag && preventDefault) {\n                e.preventDefault();\n            }\n        }\n        if (!this.flag) {\n            return false;\n        }\n        let timer = 0;\n\n        if (isDragStart) {\n            this._attchDragEvent();\n\n            // wait pinch\n            if (isTouch && pinchOutside) {\n                timer = setTimeout(() => {\n                    addEvent(container!, \"touchstart\", this.onDragStart, {\n                        passive: false\n                    });\n                });\n            }\n        } else if (isTouch && pinchOutside) {\n            // pinch is occured\n            removeEvent(container!, \"touchstart\", this.onDragStart);\n        }\n        if (this.flag && isMultiTouch(e)) {\n            clearTimeout(timer);\n            if (isDragStart && (e.touches.length !== e.changedTouches.length)) {\n                return;\n            }\n            if (!this.pinchFlag) {\n                this.onPinchStart(e);\n            }\n        }\n\n    }\n    public onDrag = (e: any, isScroll?: boolean) => {\n        if (!this.flag) {\n            return;\n        }\n        const {\n            preventDefault,\n        } = this.options;\n        if (!this._isMouseEvent && preventDefault) {\n            e.preventDefault();\n        }\n        const clients = getEventClients(e);\n        const result = this.moveClients(clients, e, false);\n\n        if (this._dragFlag) {\n            if (this.pinchFlag || result.deltaX || result.deltaY) {\n                const dragResult = this._preventMouseEvent || this.emit(\"drag\", {\n                    ...result,\n                    isScroll: !!isScroll,\n                    inputEvent: e,\n                });\n\n                if (dragResult === false) {\n                    this.stop();\n                    return;\n                }\n            }\n            if (this.pinchFlag) {\n                this.onPinch(e, clients);\n            }\n        }\n\n        this.getCurrentStore().getPosition(clients, true);\n    }\n    public onDragEnd = (e?: any) => {\n        if (!this.flag) {\n            return;\n        }\n        const {\n            pinchOutside,\n            container,\n            preventClickEventOnDrag,\n            preventClickEventOnDragStart,\n            preventClickEventByCondition,\n        } = this.options;\n        const isDrag = this.isDrag;\n\n        if (preventClickEventOnDrag || preventClickEventOnDragStart || preventClickEventByCondition) {\n            requestAnimationFrame(() => {\n                this._allowClickEvent();\n            });\n        }\n        if (!preventClickEventByCondition && !preventClickEventOnDragStart && preventClickEventOnDrag && !isDrag) {\n            this._allowClickEvent();\n        }\n\n        if (this.isTouch && pinchOutside) {\n            removeEvent(container!, \"touchstart\", this.onDragStart);\n        }\n        if (this.pinchFlag) {\n            this.onPinchEnd(e);\n        }\n        const clients = e?.touches ? getEventClients(e) : [];\n        const clientsLength = clients.length;\n\n        if (clientsLength === 0 || !this.options.keepDragging) {\n            this.flag = false;\n        } else {\n            this._addStore(new ClientStore(clients));\n        }\n\n\n        const position = this._getPosition();\n        const currentTime = now();\n        const isDouble = !isDrag && this.doubleFlag;\n\n        this.prevTime = isDrag || isDouble ? 0 : currentTime;\n\n        if (!this.flag) {\n            this._dettachDragEvent();\n\n            this._preventMouseEvent || this.emit(\"dragEnd\", {\n                data: this.data,\n                datas: this.data,\n                isDouble,\n                isDrag: isDrag,\n                isClick: !isDrag,\n                isMouseEvent: this._isMouseEvent,\n                isSecondaryButton: this._isSecondaryButton,\n                inputEvent: e,\n                ...position,\n            });\n\n            this.clientStores = [];\n\n            if (!this._isMouseEvent) {\n                this._preventMouseEvent = true;\n                requestAnimationFrame(() => {\n                    requestAnimationFrame(() => {\n                        this._preventMouseEvent = false;\n                    });\n                });\n            }\n        }\n    }\n    public onPinchStart(e: TouchEvent) {\n        const { pinchThreshold } = this.options;\n\n        if (this.isDrag && this.getMovement() > pinchThreshold!) {\n            return;\n        }\n        const store = new ClientStore(getEventClients(e));\n\n        this.pinchFlag = true;\n        this._addStore(store);\n\n        const result = this.emit(\"pinchStart\", {\n            data: this.data,\n            datas: this.data,\n            angle: store.getAngle(),\n            touches: this.getCurrentStore().getPositions(),\n            ...store.getPosition(),\n            inputEvent: e,\n        });\n\n        if (result === false) {\n            this.pinchFlag = false;\n        }\n    }\n    public onPinch(e: TouchEvent, clients: Client[]) {\n        if (!this.flag || !this.pinchFlag || clients.length < 2) {\n            return;\n        }\n\n        const store = this.getCurrentStore();\n        this.isPinch = true;\n\n        this.emit(\"pinch\", {\n            data: this.data,\n            datas: this.data,\n            movement: this.getMovement(clients),\n            angle: store.getAngle(clients),\n            rotation: store.getRotation(clients),\n            touches: store.getPositions(clients),\n            scale: store.getScale(clients),\n            distance: store.getDistance(clients),\n            ...store.getPosition(clients),\n            inputEvent: e,\n        });\n    }\n    public onPinchEnd(e: TouchEvent) {\n        if (!this.pinchFlag) {\n            return;\n        }\n        const isPinch = this.isPinch;\n\n        this.isPinch = false;\n        this.pinchFlag = false;\n        const store = this.getCurrentStore();\n        this.emit(\"pinchEnd\", {\n            data: this.data,\n            datas: this.data,\n            isPinch,\n            touches: store.getPositions(),\n            ...store.getPosition(),\n            inputEvent: e,\n        });\n    }\n    private getCurrentStore() {\n        return this.clientStores[0];\n    }\n    private moveClients(clients: Client[], inputEvent: any, isAdd: boolean): TargetParam<OnDrag> {\n        const position = this._getPosition(clients, isAdd);\n\n        if (position.deltaX || position.deltaY) {\n            this.isDrag = true;\n        }\n\n        return {\n            data: this.data,\n            datas: this.data,\n            ...position,\n            movement: this.getMovement(clients),\n            isDrag: this.isDrag,\n            isPinch: this.isPinch,\n            isScroll: false,\n            isMouseEvent: this._isMouseEvent,\n            isSecondaryButton: this._isSecondaryButton,\n            inputEvent,\n        };\n    }\n    private onBlur = () => {\n        this.onDragEnd();\n    }\n    private _addStore(store: ClientStore) {\n        this.clientStores.splice(0, 0, store);\n    }\n    private _getPosition(clients?: Client[], isAdd?: boolean) {\n        const store = this.getCurrentStore();\n        const position = store.getPosition(clients, isAdd);\n\n        const { distX, distY } = this.clientStores.slice(1).reduce((prev, cur) => {\n            const storePosition = cur.getPosition();\n\n            prev.distX += storePosition.distX;\n            prev.distY += storePosition.distY;\n            return prev;\n        }, position);\n\n        return {\n            ...position,\n            distX,\n            distY,\n        };\n    }\n    private _allowClickEvent = () => {\n        removeEvent(window, \"click\", this._onClick, true);\n    };\n    private _attchDragEvent() {\n        const container = this.options.container!;\n        const passive = {\n            passive: false\n        };\n\n        if (this.isMouse) {\n            addEvent(container, \"mousemove\", this.onDrag);\n            addEvent(container, \"mouseup\", this.onDragEnd);\n        }\n\n        if (this.isTouch) {\n            addEvent(container, \"touchmove\", this.onDrag, passive);\n            addEvent(container, \"touchend\", this.onDragEnd, passive);\n            addEvent(container, \"touchcancel\", this.onDragEnd, passive);\n        }\n    };\n    private _dettachDragEvent() {\n        const container = this.options.container!;\n\n        if (this.isMouse) {\n            removeEvent(container, \"mousemove\", this.onDrag);\n            removeEvent(container, \"mouseup\", this.onDragEnd);\n        }\n\n        if (this.isTouch) {\n            removeEvent(container, \"touchstart\", this.onDragStart);\n            removeEvent(container, \"touchmove\", this.onDrag);\n            removeEvent(container, \"touchend\", this.onDragEnd);\n            removeEvent(container, \"touchcancel\", this.onDragEnd);\n        }\n    };\n    private _onClick = (e: MouseEvent) => {\n        this._allowClickEvent();\n        this._preventMouseEvent = false;\n        const preventClickEventByCondition = this.options.preventClickEventByCondition;\n        if (preventClickEventByCondition?.(e)) {\n            return;\n        }\n        e.stopPropagation();\n        e.preventDefault();\n    }\n    private _onContextMenu = (e: MouseEvent) => {\n        const options = this.options;\n        if (!options.preventRightClick) {\n            e.preventDefault();\n        } else {\n            this.onDragEnd(e);\n        }\n    }\n    private _passCallback = () => {};\n}\n\nexport default Gesto;\n","\nimport Dragger, * as modules from \"./index\";\n\nfor (const name in modules) {\n    (Dragger as any)[name] = (modules as any)[name];\n}\n\nexport default Dragger;\n"],"names":["getRotatiion","touches","pos1","pos2","distX","distY","rad","Math","atan2","PI","getRad","clientX","clientY","getEventClients","e","length","min","clients","i","push","getClient","getClients","getPosition","prevClients","startClients","_a","getAverageClient","originalClientX","originalClientY","_b","prevX","prevY","_c","deltaX","deltaY","getDist","sqrt","pow","sumClient","client","this","isAdd","position","movement","map","startClient","currentClient","prevClient","forEach","INPUT_TAGNAMES","targets","options","_super","_this","isTrusted","flag","cancelable","container","pinchOutside","preventWheelClick","preventRightClick","preventDefault","checkInput","preventClickEventOnDragStart","preventClickEventOnDrag","preventClickEventByCondition","isTouch","isDragStart","_isSecondaryButton","which","button","stop","activeElement","document","target","tagName","toLowerCase","hasInput","indexOf","hasContentEditable","isContentEditable","contains","type","activeTagName","blur","addEvent","window","_onClick","clientStores","ClientStore","isDrag","_dragFlag","data","doubleFlag","now","prevTime","_isMouseEvent","isMouseEvent","_preventMouseEvent","emit","datas","inputEvent","isSecondaryButton","isDouble","getCurrentStore","preventDrag","timer","_attchDragEvent","setTimeout","onDragStart","passive","removeEvent","isMultiTouch","clearTimeout","changedTouches","pinchFlag","onPinchStart","isScroll","result","moveClients","onPinch","requestAnimationFrame","_allowClickEvent","onPinchEnd","keepDragging","_addStore","_getPosition","currentTime","_dettachDragEvent","isClick","onDragEnd","stopPropagation","elements","concat","checkWindowBlur","pinchThreshold","events","isMouse","el","_passCallback","_onContextMenu","onBlur","passive_1","__extends","getMovement","slice","reduce","prev","cur","isPinch","isCallDrag","move","onDrag","nextClients","currentData","name","setEventData","off","store","angle","getAngle","getPositions","rotation","getRotation","scale","getScale","distance","getDistance","splice","storePosition","EventEmitter","modules","Dragger"],"mappings":"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"}