{"version":3,"file":"drag.min.js","sources":["../src/utils.ts","../src/Dragger.ts","../src/drag.ts","../src/index.umd.ts"],"sourcesContent":["import { Client, Position } from \"./types\";\nimport { IArrayFormat } from \"@daybrush/utils\";\n\nexport function getPinchDragPosition(\n    clients: Client[],\n    prevClients: Client[],\n    startClients: Client[],\n    startPinchClients: Client[],\n) {\n    const nowCenter = getAverageClient(clients);\n    const prevCenter = getAverageClient(prevClients);\n    const startCenter = getAverageClient(startPinchClients);\n    const pinchClient = plueClient(startPinchClients[0], minusClient(nowCenter, startCenter));\n    const pinchPrevClient = plueClient(startPinchClients[0], minusClient(prevCenter, startCenter));\n\n    return getPosition(pinchClient, pinchPrevClient, startClients[0]);\n}\nexport function isMultiTouch(e: any): e is TouchEvent {\n    return e.touches && e.touches.length >= 2;\n}\nexport function getPositionEvent(e: any): Client[] {\n    if (e.touches) {\n        return getClients(e.touches);\n    } else {\n        return [getClient(e)];\n    }\n}\nexport function getPosition(client: Client, prevClient: Client, startClient: Client): Position {\n    const { clientX, clientY } = client;\n    const {\n        clientX: prevX,\n        clientY: prevY,\n    } = prevClient;\n\n    const {\n        clientX: startX,\n        clientY: startY,\n    } = startClient;\n    const deltaX = clientX - prevX;\n    const deltaY = clientY - prevY;\n    const distX = clientX - startX;\n    const distY = clientY - startY;\n\n    return {\n        clientX,\n        clientY,\n        deltaX,\n        deltaY,\n        distX,\n        distY,\n    };\n}\nexport function getDist(clients: Client[]) {\n    return Math.sqrt(\n        Math.pow(clients[0].clientX - clients[1].clientX, 2)\n        + Math.pow(clients[0].clientY - clients[1].clientY, 2),\n    );\n}\nexport function getPositions(clients: Client[], prevClients: Client[], startClients: Client[]): Position[] {\n    return clients.map((client, i) => getPosition(client, prevClients[i], startClients[i]));\n}\nexport function getClients(touches: IArrayFormat<Touch>) {\n    const length = Math.min(touches.length, 2);\n    const clients = [];\n\n    for (let i = 0; i < length; ++i) {\n        clients.push(getClient(touches[i]));\n    }\n    return clients;\n}\nexport function getClient(e: MouseEvent | Touch): Client {\n    return {\n        clientX: e.clientX,\n        clientY: e.clientY,\n    };\n}\nexport function getAverageClient(clients: Client[]) {\n    if (clients.length === 1) {\n        return clients[0];\n    }\n    return {\n        clientX: (clients[0].clientX + clients[1].clientX) / 2,\n        clientY: (clients[0].clientY + clients[1].clientY) / 2,\n    };\n}\nexport function plueClient(client1: Client, client2: Client) {\n    return {\n        clientX: (client1.clientX + client2.clientX),\n        clientY: (client1.clientY + client2.clientY),\n    };\n}\n\nexport function minusClient(client1: Client, client2: Client) {\n    return {\n        clientX: (client1.clientX - client2.clientX),\n        clientY: (client1.clientY - client2.clientY),\n    };\n}\n","import { DragOptions, Client, Position, OnDrag } from \"./types\";\nimport {\n    getPositionEvent, getPosition, getClients, getPositions,\n    isMultiTouch, getPinchDragPosition, getAverageClient, getDist,\n} from \"./utils\";\nimport { addEvent, removeEvent } from \"@daybrush/utils\";\n\n/**\n * You can set up drag events in any browser.\n */\nclass Dragger {\n    public options: DragOptions = {};\n    private flag = false;\n    private pinchFlag = false;\n    private datas = {};\n    private isDrag = false;\n    private isPinch = false;\n    private isMouse = false;\n    private isTouch = false;\n    private prevClients: Client[] = [];\n    private startClients: Client[] = [];\n    private movement: number = 0;\n    private startPinchClients: Client[] = [];\n    private startDistance: number = 0;\n    private customDist = [0, 0];\n    private targets: Array<Element | Window> = [];\n    /**\n     *\n     */\n    constructor(targets: Array<Element | Window> | Element | Window, options: DragOptions = {}) {\n        const elements = [].concat(targets as any) as Array<Element | Window> ;\n        this.options = {\n            container: elements.length > 1 ? window : elements[0],\n            preventRightClick: true,\n            preventDefault: true,\n            pinchThreshold: 0,\n            events: [\"touch\", \"mouse\"],\n            ...options,\n        };\n\n        const { container, events } = this.options;\n\n        this.isTouch = events!.indexOf(\"touch\") > -1;\n        this.isMouse = events!.indexOf(\"mouse\") > -1;\n        this.customDist = [0, 0];\n        this.targets = elements;\n\n        if (this.isMouse) {\n            elements.forEach(el => {\n                addEvent(el, \"mousedown\", this.onDragStart);\n            });\n            addEvent(container!, \"mousemove\", this.onDrag);\n            addEvent(container!, \"mouseup\", this.onDragEnd);\n        }\n        if (this.isTouch) {\n            const passive = {\n                passive: false,\n            };\n            elements.forEach(el => {\n                addEvent(el, \"touchstart\", this.onDragStart, passive);\n            });\n            addEvent(container!, \"touchmove\", this.onDrag, passive);\n            addEvent(container!, \"touchend\", this.onDragEnd, passive);\n            addEvent(container!, \"touchcancel\", this.onDragEnd, passive);\n        }\n    }\n    /**\n     *\n     */\n    public isDragging() {\n        return this.isDrag;\n    }\n    /**\n     *\n     */\n    public isFlag() {\n        return this.flag;\n    }\n    /**\n     *\n     */\n    public isPinchFlag() {\n        return this.pinchFlag;\n    }\n    /**\n     *\n     */\n    public isPinching() {\n        return this.isPinch;\n    }\n    /**\n     *\n     */\n    public scrollBy(deltaX: number, deltaY: number, e: any, isCallDrag: boolean = true) {\n        if (!this.flag) {\n            return;\n        }\n        this.startClients.forEach(client => {\n            client.clientX -= deltaX;\n            client.clientY -= deltaY;\n        });\n        this.prevClients.forEach(client => {\n            client.clientX -= deltaX;\n            client.clientY -= deltaY;\n        });\n        isCallDrag && this.onDrag(e, true);\n    }\n    /**\n     * @method\n     */\n    public onDragStart = (e: any) => {\n        if (!this.flag && e.cancelable === false) {\n            return;\n        }\n        const { container, pinchOutside, dragstart, preventRightClick } = this.options;\n        const isTouch = this.isTouch;\n\n        if (!this.flag && isTouch && pinchOutside) {\n            setTimeout(() => {\n                addEvent(container!, \"touchstart\", this.onDragStart);\n            });\n        }\n        if (this.flag && isTouch && pinchOutside) {\n            removeEvent(container!, \"touchstart\", this.onDragStart);\n        }\n        if (isMultiTouch(e)) {\n            if (!this.flag && (e.touches.length !== e.changedTouches.length)) {\n                return;\n            }\n            if (!this.pinchFlag) {\n                this.onPinchStart(e);\n            }\n        }\n        if (this.flag) {\n            return;\n        }\n        const clients = this.startClients[0] ? this.startClients : getPositionEvent(e);\n\n        this.customDist = [0, 0];\n        this.flag = true;\n        this.isDrag = false;\n        this.startClients = clients;\n        this.prevClients = clients;\n        this.datas = {};\n        this.movement = 0;\n\n        const position = getPosition(clients[0], this.prevClients[0], this.startClients[0]);\n\n        if (\n            (preventRightClick && e.which === 3)\n            || (dragstart && dragstart({\n                type: \"dragstart\",\n                datas: this.datas,\n                inputEvent: e,\n                ...position,\n            })) === false) {\n            this.startClients = [];\n            this.prevClients = [];\n            this.flag = false;\n        }\n        this.flag && e.preventDefault();\n    }\n    public onDrag = (e: any, isScroll?: boolean) => {\n        if (!this.flag) {\n            return;\n        }\n        const clients = getPositionEvent(e);\n\n        if (this.pinchFlag) {\n            this.onPinch(e, clients);\n        }\n        const result = this.move([0, 0], e, clients);\n\n        if (!result || (!result.deltaX && !result.deltaY)) {\n            return;\n        }\n        const drag = this.options.drag;\n\n        drag && drag({\n            ...result,\n            isScroll: !!isScroll,\n            inputEvent: e,\n        });\n    }\n    public move([deltaX, deltaY]: number[], inputEvent: any, clients = this.prevClients): OnDrag | undefined {\n        const customDist = this.customDist;\n        const prevClients = this.prevClients;\n        const startClients = this.startClients;\n        const position: Position = this.pinchFlag\n            ? getPinchDragPosition(clients, prevClients, startClients, this.startPinchClients)\n            : getPosition(clients[0], prevClients[0], startClients[0]);\n\n        customDist[0] += deltaX;\n        customDist[1] += deltaY;\n        position.deltaX += deltaX;\n        position.deltaY += deltaY;\n\n        const {\n            deltaX: positionDeltaX,\n            deltaY: positionDeltaY,\n        } = position;\n\n        position.distX += customDist[0];\n        position.distY += customDist[1];\n\n        this.movement += Math.sqrt(positionDeltaX * positionDeltaX + positionDeltaY * positionDeltaY);\n        this.prevClients = clients;\n        this.isDrag = true;\n\n        return {\n            type: \"drag\",\n            datas: this.datas,\n            ...position,\n            movement: this.movement,\n            isDrag: this.isDrag,\n            isPinch: this.isPinch,\n            isScroll: false,\n            inputEvent,\n        };\n    }\n    public onDragEnd = (e: any) => {\n        if (!this.flag) {\n            return;\n        }\n        const { dragend, pinchOutside, container } = this.options;\n        if (this.isTouch && pinchOutside) {\n            removeEvent(container!, \"touchstart\", this.onDragStart);\n        }\n        if (this.pinchFlag) {\n            this.onPinchEnd(e);\n        }\n        this.flag = false;\n\n        const prevClients = this.prevClients;\n        const startClients = this.startClients;\n\n        const position: Position = this.pinchFlag\n            ? getPinchDragPosition(prevClients, prevClients, startClients, this.startPinchClients)\n            : getPosition(prevClients[0], prevClients[0], startClients[0]);\n\n        this.startClients = [];\n        this.prevClients = [];\n        dragend && dragend({\n            type: \"dragend\",\n            datas: this.datas,\n            isDrag: this.isDrag,\n            inputEvent: e,\n            ...position,\n        });\n    }\n    public onPinchStart(e: TouchEvent) {\n        const { pinchstart, pinchThreshold } = this.options;\n\n        if (this.isDrag && this.movement > pinchThreshold!) {\n            return;\n        }\n        const pinchClients = getClients(e.changedTouches);\n\n        this.pinchFlag = true;\n        this.startClients.push(...pinchClients);\n        this.prevClients.push(...pinchClients);\n        this.startDistance = getDist(this.prevClients);\n        this.startPinchClients = [...this.prevClients];\n\n        if (!pinchstart) {\n            return;\n        }\n        const startClients = this.prevClients;\n        const startAverageClient = getAverageClient(startClients);\n        const centerPosition = getPosition(\n            startAverageClient,\n            startAverageClient,\n            startAverageClient,\n        );\n        pinchstart({\n            type: \"pinchstart\",\n            datas: this.datas,\n            touches: getPositions(startClients, startClients, startClients),\n            ...centerPosition,\n            inputEvent: e,\n        });\n    }\n    public onPinch(e: TouchEvent, clients: Client[]) {\n        if (!this.flag || !this.pinchFlag || clients.length < 2) {\n            return;\n        }\n        this.isPinch = true;\n\n        const pinch = this.options.pinch;\n        if (!pinch) {\n            return;\n        }\n        const prevClients = this.prevClients;\n        const startClients = this.startClients;\n        const centerPosition = getPosition(\n            getAverageClient(clients),\n            getAverageClient(prevClients),\n            getAverageClient(startClients),\n        );\n        const distance = getDist(clients);\n        pinch({\n            type: \"pinch\",\n            datas: this.datas,\n            movement: this.movement,\n            touches: getPositions(clients, prevClients, startClients),\n            scale: distance / this.startDistance,\n            distance,\n            ...centerPosition,\n            inputEvent: e,\n        });\n    }\n    public onPinchEnd(e: TouchEvent) {\n        if (!this.flag || !this.pinchFlag) {\n            return;\n        }\n        const isPinch = this.isPinch;\n\n        this.isPinch = false;\n        this.pinchFlag = false;\n        const pinchend = this.options.pinchend;\n\n        if (!pinchend) {\n            return;\n        }\n        const prevClients = this.prevClients;\n        const startClients = this.startClients;\n        const centerPosition = getPosition(\n            getAverageClient(prevClients),\n            getAverageClient(prevClients),\n            getAverageClient(startClients),\n        );\n        pinchend({\n            type: \"pinchend\",\n            datas: this.datas,\n            isPinch,\n            touches: getPositions(prevClients, prevClients, startClients),\n            ...centerPosition,\n            inputEvent: e,\n        });\n        this.isPinch = false;\n        this.pinchFlag = false;\n    }\n    /**\n     *\n     */\n    public unset() {\n        const targets = this.targets;\n        const container = this.options.container!;\n\n        if (this.isMouse) {\n            targets.forEach(target => {\n                removeEvent(target, \"mousedown\", this.onDragStart);\n            });\n            removeEvent(container, \"mousemove\", this.onDrag);\n            removeEvent(container, \"mouseup\", this.onDragEnd);\n        }\n        if (this.isTouch) {\n            targets.forEach(target => {\n                removeEvent(target, \"touchstart\", this.onDragStart);\n            });\n            removeEvent(container, \"touchstart\", this.onDragStart);\n            removeEvent(container, \"touchmove\", this.onDrag);\n            removeEvent(container, \"touchend\", this.onDragEnd);\n            removeEvent(container, \"touchcancel\", this.onDragEnd);\n        }\n    }\n}\n\nexport default Dragger;\n","import Dragger from \"./Dragger\";\nimport { DragOptions } from \"./types\";\n\nexport default function setDrag(el: Element, options: DragOptions) {\n    return new Dragger(el, options);\n}\n","\nimport Dragger, * as modules from \"./index\";\n\nfor (const name in modules) {\n    (Dragger as any)[name] = (modules as any)[name];\n}\n\nexport default Dragger;\n"],"names":["getPinchDragPosition","clients","prevClients","startClients","startPinchClients","nowCenter","getAverageClient","prevCenter","startCenter","getPosition","plueClient","minusClient","getPositionEvent","e","touches","getClients","getClient","client","prevClient","startClient","clientX","clientY","deltaX","deltaY","distX","distY","getDist","Math","sqrt","pow","getPositions","map","i","length","min","push","client1","client2","targets","options","_this","flag","cancelable","_a","container","pinchOutside","dragstart","preventRightClick","isTouch","setTimeout","addEvent","onDragStart","removeEvent","isMultiTouch","changedTouches","pinchFlag","onPinchStart","customDist","isDrag","datas","position","movement","which","type","inputEvent","preventDefault","isScroll","onPinch","result","move","drag","dragend","onPinchEnd","elements","concat","window","pinchThreshold","events","indexOf","isMouse","this","forEach","el","onDrag","onDragEnd","passive_1","passive","isPinch","isCallDrag","positionDeltaX","positionDeltaY","_c","pinchstart","pinchClients","_b","startDistance","startAverageClient","centerPosition","pinch","distance","scale","pinchend","target","Dragger","name","modules"],"mappings":"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"}