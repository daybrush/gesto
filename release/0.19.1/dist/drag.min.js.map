{"version":3,"file":"drag.min.js","sources":["../src/utils.ts","../src/Dragger.ts","../src/drag.ts","../src/index.umd.ts"],"sourcesContent":["import { Client, Position } from \"./types\";\nimport { IArrayFormat } from \"@daybrush/utils\";\n\nexport function getRad(pos1: number[], pos2: number[]) {\n    const distX = pos2[0] - pos1[0];\n    const distY = pos2[1] - pos1[1];\n    const rad = Math.atan2(distY, distX);\n\n    return rad >= 0 ? rad : rad + Math.PI * 2;\n}\n\nexport function getRotatiion(touches: Client[]) {\n    return getRad([\n        touches[0].clientX,\n        touches[0].clientY,\n    ], [\n        touches[1].clientX,\n        touches[1].clientY,\n    ]) / Math.PI * 180;\n}\n\nexport function getPinchDragPosition(\n    clients: Client[],\n    prevClients: Client[],\n    startClients: Client[],\n    startPinchClients: Client[],\n) {\n    const nowCenter = getAverageClient(clients);\n    const prevCenter = getAverageClient(prevClients);\n    const startCenter = getAverageClient(startPinchClients);\n    const pinchClient = plueClient(startPinchClients[0], minusClient(nowCenter, startCenter));\n    const pinchPrevClient = plueClient(startPinchClients[0], minusClient(prevCenter, startCenter));\n\n    return getPosition(pinchClient, pinchPrevClient, startClients[0]);\n}\nexport function isMultiTouch(e: any): e is TouchEvent {\n    return e.touches && e.touches.length >= 2;\n}\nexport function getPositionEvent(e: any): Client[] {\n    if (e.touches) {\n        return getClients(e.touches);\n    } else {\n        return [getClient(e)];\n    }\n}\nexport function getPosition(client: Client, prevClient: Client, startClient: Client): Position {\n    const { clientX, clientY } = client;\n    const {\n        clientX: prevX,\n        clientY: prevY,\n    } = prevClient;\n\n    const {\n        clientX: startX,\n        clientY: startY,\n    } = startClient;\n    const deltaX = clientX - prevX;\n    const deltaY = clientY - prevY;\n    const distX = clientX - startX;\n    const distY = clientY - startY;\n\n    return {\n        clientX,\n        clientY,\n        deltaX,\n        deltaY,\n        distX,\n        distY,\n    };\n}\nexport function getDist(clients: Client[]) {\n    return Math.sqrt(\n        Math.pow(clients[0].clientX - clients[1].clientX, 2)\n        + Math.pow(clients[0].clientY - clients[1].clientY, 2),\n    );\n}\nexport function getPositions(clients: Client[], prevClients: Client[], startClients: Client[]): Position[] {\n    return clients.map((client, i) => getPosition(client, prevClients[i], startClients[i]));\n}\nexport function getClients(touches: IArrayFormat<Touch>) {\n    const length = Math.min(touches.length, 2);\n    const clients = [];\n\n    for (let i = 0; i < length; ++i) {\n        clients.push(getClient(touches[i]));\n    }\n    return clients;\n}\nexport function getClient(e: MouseEvent | Touch): Client {\n    return {\n        clientX: e.clientX,\n        clientY: e.clientY,\n    };\n}\nexport function getAverageClient(clients: Client[]) {\n    if (clients.length === 1) {\n        return clients[0];\n    }\n    return {\n        clientX: (clients[0].clientX + clients[1].clientX) / 2,\n        clientY: (clients[0].clientY + clients[1].clientY) / 2,\n    };\n}\nexport function plueClient(client1: Client, client2: Client) {\n    return {\n        clientX: (client1.clientX + client2.clientX),\n        clientY: (client1.clientY + client2.clientY),\n    };\n}\n\nexport function minusClient(client1: Client, client2: Client) {\n    return {\n        clientX: (client1.clientX - client2.clientX),\n        clientY: (client1.clientY - client2.clientY),\n    };\n}\n","import { DragOptions, Client, Position, OnDrag } from \"./types\";\nimport {\n    getPositionEvent, getPosition, getClients, getPositions,\n    isMultiTouch, getPinchDragPosition, getAverageClient, getDist, getRotatiion,\n} from \"./utils\";\nimport { addEvent, removeEvent, now } from \"@daybrush/utils\";\n\nconst INPUT_TAGNAMES = [\"textarea\", \"input\"];\n/**\n * You can set up drag events in any browser.\n */\nclass Dragger {\n    public options: DragOptions = {};\n    private flag = false;\n    private pinchFlag = false;\n    private datas = {};\n    private isDrag = false;\n    private isPinch = false;\n    private isMouse = false;\n    private isTouch = false;\n    private prevClients: Client[] = [];\n    private startClients: Client[] = [];\n    private movement: number = 0;\n    private startPinchClients: Client[] = [];\n    private startDistance: number = 0;\n    private customDist = [0, 0];\n    private targets: Array<Element | Window> = [];\n    private prevTime: number = 0;\n    private isDouble: boolean = false;\n    private startRotate = 0;\n    /**\n     *\n     */\n    constructor(targets: Array<Element | Window> | Element | Window, options: DragOptions = {}) {\n        const elements = [].concat(targets as any) as Array<Element | Window>;\n        this.options = {\n            checkInput: false,\n            container: elements.length > 1 ? window : elements[0],\n            preventRightClick: true,\n            preventDefault: true,\n            pinchThreshold: 0,\n            events: [\"touch\", \"mouse\"],\n            ...options,\n        };\n\n        const { container, events } = this.options;\n\n        this.isTouch = events!.indexOf(\"touch\") > -1;\n        this.isMouse = events!.indexOf(\"mouse\") > -1;\n        this.customDist = [0, 0];\n        this.targets = elements;\n\n        if (this.isMouse) {\n            elements.forEach(el => {\n                addEvent(el, \"mousedown\", this.onDragStart);\n            });\n            addEvent(container!, \"mousemove\", this.onDrag);\n            addEvent(container!, \"mouseup\", this.onDragEnd);\n            addEvent(container!, \"contextmenu\", this.onDragEnd);\n        }\n        if (this.isTouch) {\n            const passive = {\n                passive: false,\n            };\n            elements.forEach(el => {\n                addEvent(el, \"touchstart\", this.onDragStart, passive);\n            });\n            addEvent(container!, \"touchmove\", this.onDrag, passive);\n            addEvent(container!, \"touchend\", this.onDragEnd, passive);\n            addEvent(container!, \"touchcancel\", this.onDragEnd, passive);\n        }\n    }\n    /**\n     *\n     */\n    public isDragging() {\n        return this.isDrag;\n    }\n    /**\n     *\n     */\n    public isFlag() {\n        return this.flag;\n    }\n    /**\n     *\n     */\n    public isPinchFlag() {\n        return this.pinchFlag;\n    }\n    /**\n     *\n     */\n    public isPinching() {\n        return this.isPinch;\n    }\n    /**\n     *\n     */\n    public scrollBy(deltaX: number, deltaY: number, e: any, isCallDrag: boolean = true) {\n        if (!this.flag) {\n            return;\n        }\n        this.startClients.forEach(client => {\n            client.clientX -= deltaX;\n            client.clientY -= deltaY;\n        });\n        this.prevClients.forEach(client => {\n            client.clientX -= deltaX;\n            client.clientY -= deltaY;\n        });\n        isCallDrag && this.onDrag(e, true);\n    }\n    /**\n     * @method\n     */\n    public onDragStart = (e: any, isTrusted = true) => {\n        if (!this.flag && e.cancelable === false) {\n            return;\n        }\n        const { container, pinchOutside, dragstart, preventRightClick, preventDefault, checkInput } = this.options;\n        const isTouch = this.isTouch;\n\n        if (!this.flag) {\n            const activeElement = document.activeElement as HTMLElement;\n            const target = e.target as HTMLElement;\n            const tagName = target.tagName.toLowerCase();\n            const hasInput = INPUT_TAGNAMES.indexOf(tagName) > -1;\n            const hasContentEditable = target.isContentEditable;\n\n            if (hasInput || hasContentEditable) {\n                if (checkInput || activeElement === target) {\n                    // force false or already focused.\n                    return false;\n                }\n                if (\n                    activeElement\n                    && hasContentEditable\n                    && activeElement.isContentEditable\n                    && activeElement.contains(target)\n                ) {\n                    return false;\n                }\n            } else if ((preventDefault || e.type === \"touchstart\") && activeElement) {\n                const activeTagName = activeElement.tagName;\n                if (activeElement.isContentEditable || INPUT_TAGNAMES.indexOf(activeTagName) > -1) {\n                    activeElement.blur();\n                }\n            }\n        }\n        let timer = 0;\n\n        if (!this.flag && isTouch && pinchOutside) {\n            timer = setTimeout(() => {\n                addEvent(container!, \"touchstart\", this.onDragStart, { passive: false });\n            });\n        }\n        if (this.flag && isTouch && pinchOutside) {\n            removeEvent(container!, \"touchstart\", this.onDragStart);\n        }\n        if (isMultiTouch(e)) {\n            clearTimeout(timer);\n            if (!this.flag && (e.touches.length !== e.changedTouches.length)) {\n                return;\n            }\n            if (!this.pinchFlag) {\n                this.onPinchStart(e);\n            }\n        }\n        if (this.flag) {\n            return;\n        }\n        const clients = this.startClients[0] ? this.startClients : getPositionEvent(e);\n\n        this.customDist = [0, 0];\n        this.flag = true;\n        this.isDrag = false;\n        this.startClients = clients;\n        this.prevClients = clients;\n        this.datas = {};\n        this.movement = 0;\n\n        const position = getPosition(clients[0], this.prevClients[0], this.startClients[0]);\n\n        if (preventRightClick && (e.which === 3 || e.button === 2)) {\n            clearTimeout(timer);\n            this.initDrag();\n            return false;\n        }\n        const result = dragstart && dragstart({\n            type: \"dragstart\",\n            datas: this.datas,\n            inputEvent: e,\n            isTrusted,\n            ...position,\n        });\n        if (result === false) {\n            clearTimeout(timer);\n            this.initDrag();\n        }\n        this.isDouble = now() - this.prevTime < 200;\n        this.flag && preventDefault && e.preventDefault();\n    }\n    public onDrag = (e: any, isScroll?: boolean) => {\n        if (!this.flag) {\n            return;\n        }\n        const clients = getPositionEvent(e);\n\n        if (this.pinchFlag) {\n            this.onPinch(e, clients);\n        }\n        const result = this.move([0, 0], e, clients);\n\n        if (!result || (!result.deltaX && !result.deltaY)) {\n            return;\n        }\n        const drag = this.options.drag;\n\n        drag && drag({\n            ...result,\n            isScroll: !!isScroll,\n            inputEvent: e,\n        });\n    }\n    public move([deltaX, deltaY]: number[], inputEvent: any, clients = this.prevClients): OnDrag | undefined {\n        const customDist = this.customDist;\n        const prevClients = this.prevClients;\n        const startClients = this.startClients;\n        const position: Position = this.pinchFlag\n            ? getPinchDragPosition(clients, prevClients, startClients, this.startPinchClients)\n            : getPosition(clients[0], prevClients[0], startClients[0]);\n\n        customDist[0] += deltaX;\n        customDist[1] += deltaY;\n        position.deltaX += deltaX;\n        position.deltaY += deltaY;\n\n        const {\n            deltaX: positionDeltaX,\n            deltaY: positionDeltaY,\n        } = position;\n\n        position.distX += customDist[0];\n        position.distY += customDist[1];\n\n        this.movement += Math.sqrt(positionDeltaX * positionDeltaX + positionDeltaY * positionDeltaY);\n        this.prevClients = clients;\n        this.isDrag = true;\n\n        return {\n            type: \"drag\",\n            datas: this.datas,\n            ...position,\n            movement: this.movement,\n            isDrag: this.isDrag,\n            isPinch: this.isPinch,\n            isScroll: false,\n            inputEvent,\n        };\n    }\n    public onDragEnd = (e: any) => {\n        if (!this.flag) {\n            return;\n        }\n        const { dragend, pinchOutside, container } = this.options;\n        if (this.isTouch && pinchOutside) {\n            removeEvent(container!, \"touchstart\", this.onDragStart);\n        }\n        if (this.pinchFlag) {\n            this.onPinchEnd(e);\n        }\n        this.flag = false;\n\n        const prevClients = this.prevClients;\n        const startClients = this.startClients;\n\n        const position: Position = this.pinchFlag\n            ? getPinchDragPosition(prevClients, prevClients, startClients, this.startPinchClients)\n            : getPosition(prevClients[0], prevClients[0], startClients[0]);\n\n        const currentTime = now();\n        const isDouble = !this.isDrag && this.isDouble;\n\n        this.prevTime = this.isDrag || isDouble ? 0 : currentTime;\n        this.startClients = [];\n        this.prevClients = [];\n\n        dragend && dragend({\n            type: \"dragend\",\n            datas: this.datas,\n            isDouble,\n            isDrag: this.isDrag,\n            inputEvent: e,\n            ...position,\n        });\n    }\n    public onPinchStart(e: TouchEvent) {\n        const { pinchstart, pinchThreshold } = this.options;\n\n        if (this.isDrag && this.movement > pinchThreshold!) {\n            return;\n        }\n        const pinchClients = getClients(e.changedTouches);\n\n        this.pinchFlag = true;\n        this.startClients.push(...pinchClients);\n        this.prevClients.push(...pinchClients);\n        this.startDistance = getDist(this.prevClients);\n        this.startPinchClients = [...this.prevClients];\n\n        if (!pinchstart) {\n            return;\n        }\n        const startClients = this.prevClients;\n        const startAverageClient = getAverageClient(startClients);\n        const centerPosition = getPosition(\n            startAverageClient,\n            startAverageClient,\n            startAverageClient,\n        );\n\n        this.startRotate = getRotatiion(startClients);\n        pinchstart({\n            type: \"pinchstart\",\n            datas: this.datas,\n            angle: this.startRotate,\n            touches: getPositions(startClients, startClients, startClients),\n            ...centerPosition,\n            inputEvent: e,\n        });\n    }\n    public onPinch(e: TouchEvent, clients: Client[]) {\n        if (!this.flag || !this.pinchFlag || clients.length < 2) {\n            return;\n        }\n        this.isPinch = true;\n\n        const pinch = this.options.pinch;\n        if (!pinch) {\n            return;\n        }\n        const prevClients = this.prevClients;\n        const startClients = this.startClients;\n        const centerPosition = getPosition(\n            getAverageClient(clients),\n            getAverageClient(prevClients),\n            getAverageClient(startClients),\n        );\n        const angle = getRotatiion(clients);\n        const distance = getDist(clients);\n        pinch({\n            type: \"pinch\",\n            datas: this.datas,\n            movement: this.movement,\n            angle,\n            rotation: angle - this.startRotate,\n            touches: getPositions(clients, prevClients, startClients),\n            scale: distance / this.startDistance,\n            distance,\n            ...centerPosition,\n            inputEvent: e,\n        });\n    }\n    public onPinchEnd(e: TouchEvent) {\n        if (!this.flag || !this.pinchFlag) {\n            return;\n        }\n        const isPinch = this.isPinch;\n\n        this.isPinch = false;\n        this.pinchFlag = false;\n        const pinchend = this.options.pinchend;\n\n        if (!pinchend) {\n            return;\n        }\n        const prevClients = this.prevClients;\n        const startClients = this.startClients;\n        const centerPosition = getPosition(\n            getAverageClient(prevClients),\n            getAverageClient(prevClients),\n            getAverageClient(startClients),\n        );\n        pinchend({\n            type: \"pinchend\",\n            datas: this.datas,\n            isPinch,\n            touches: getPositions(prevClients, prevClients, startClients),\n            ...centerPosition,\n            inputEvent: e,\n        });\n        this.isPinch = false;\n        this.pinchFlag = false;\n    }\n    public triggerDragStart(e: any) {\n        this.onDragStart(e, false);\n    }\n    /**\n     *\n     */\n    public unset() {\n        const targets = this.targets;\n        const container = this.options.container!;\n\n        if (this.isMouse) {\n            targets.forEach(target => {\n                removeEvent(target, \"mousedown\", this.onDragStart);\n            });\n            removeEvent(container, \"mousemove\", this.onDrag);\n            removeEvent(container, \"mouseup\", this.onDragEnd);\n            removeEvent(container, \"contextmenu\", this.onDragEnd);\n        }\n        if (this.isTouch) {\n            targets.forEach(target => {\n                removeEvent(target, \"touchstart\", this.onDragStart);\n            });\n            removeEvent(container, \"touchstart\", this.onDragStart);\n            removeEvent(container, \"touchmove\", this.onDrag);\n            removeEvent(container, \"touchend\", this.onDragEnd);\n            removeEvent(container, \"touchcancel\", this.onDragEnd);\n        }\n    }\n    private initDrag() {\n        this.startClients = [];\n        this.prevClients = [];\n        this.flag = false;\n    }\n}\n\nexport default Dragger;\n","import Dragger from \"./Dragger\";\nimport { DragOptions } from \"./types\";\n\nexport default function setDrag(el: Element, options: DragOptions) {\n    return new Dragger(el, options);\n}\n","\nimport Dragger, * as modules from \"./index\";\n\nfor (const name in modules) {\n    (Dragger as any)[name] = (modules as any)[name];\n}\n\nexport default Dragger;\n"],"names":["getRotatiion","touches","pos1","pos2","distX","distY","rad","Math","atan2","PI","getRad","clientX","clientY","getPinchDragPosition","clients","prevClients","startClients","startPinchClients","nowCenter","getAverageClient","prevCenter","startCenter","getPosition","plueClient","minusClient","getPositionEvent","e","getClients","getClient","client","prevClient","startClient","deltaX","deltaY","getDist","sqrt","pow","getPositions","map","i","length","min","push","client1","client2","INPUT_TAGNAMES","targets","options","isTrusted","_this","flag","cancelable","_a","container","pinchOutside","dragstart","preventRightClick","preventDefault","checkInput","isTouch","activeElement","document","target","tagName","toLowerCase","hasInput","indexOf","hasContentEditable","isContentEditable","contains","type","activeTagName","blur","timer","setTimeout","addEvent","onDragStart","passive","removeEvent","isMultiTouch","clearTimeout","changedTouches","pinchFlag","onPinchStart","customDist","isDrag","datas","position","movement","which","button","initDrag","inputEvent","isDouble","now","prevTime","isScroll","onPinch","result","move","drag","dragend","onPinchEnd","currentTime","elements","concat","window","pinchThreshold","events","isMouse","this","forEach","el","onDrag","onDragEnd","passive_1","isPinch","isCallDrag","positionDeltaX","positionDeltaY","_c","pinchstart","pinchClients","_b","startDistance","startAverageClient","centerPosition","startRotate","angle","pinch","distance","rotation","scale","pinchend","Dragger","name","modules"],"mappings":"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"}